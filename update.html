<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>AI Video Studio - Fireship Style</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet"/>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/>
    <script>
        //  load ResponsiveVoice API key from a hidden file in the same directory
        fetch('.responsivevoice-key')
            .then(response => response.text())
            .then(key => {
                const script = document.createElement('script');
                script.src = `https://code.responsivevoice.org/responsivevoice.js?key=${key.trim()}`;
                document.head.appendChild(script);
            })
            .catch(() => {
                console.warn('ResponsiveVoice key file not found or could not be loaded.');
            });
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0F172A 0%, #1E293B 100%);
            color: #E2E8F0;
            min-height: 100vh;
        }
        
        .glass-card {
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 16px;
            padding: 24px;
            transition: all 0.3s ease;
        }
        
        .glass-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #6366F1 0%, #8B5CF6 100%);
            color: white;
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 10px 20px rgba(99, 102, 241, 0.3);
        }
        
        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .btn-secondary {
            background: rgba(51, 65, 85, 0.8);
            color: #E2E8F0;
            padding: 12px 24px;
            border-radius: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
        }
        
        .btn-secondary:hover:not(:disabled) {
            background: rgba(71, 85, 105, 0.8);
            transform: translateY(-1px);
        }
        
        .input-field {
            background: rgba(30, 41, 59, 0.8);
            border: 2px solid rgba(51, 65, 85, 0.5);
            border-radius: 12px;
            padding: 16px;
            color: #E2E8F0;
            width: 100%;
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
        }
        
        .input-field:focus {
            outline: none;
            border-color: #6366F1;
            box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.1);
        }
        
        .progress-container {
            background: rgba(51, 65, 85, 0.5);
            border-radius: 12px;
            overflow: hidden;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #6366F1 0%, #8B5CF6 100%);
            border-radius: 12px;
            transition: width 0.5s ease;
            height: 8px;
        }
        
        .scene-card {
            background: rgba(30, 41, 59, 0.6);
            border: 2px solid transparent;
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.3s ease;
            position: relative;
            aspect-ratio: 1;
        }
        
        .scene-card:hover {
            border-color: #6366F1;
            transform: scale(1.02);
        }
        
        .scene-card.selected {
            border-color: #8B5CF6;
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
        }
        
        .spinner {
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top: 2px solid #fff;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            margin-right: 8px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .fireship-gradient {
            background: linear-gradient(135deg, #FF6B6B 0%, #4ECDC4 25%, #45B7D1 50%, #96CEB4 75%, #FFEAA7 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .video-preview {
            background: #000;
            border-radius: 16px;
            overflow: hidden;
            aspect-ratio: 16/9;
            position: relative;
        }
        
        .overlay-controls {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .overlay-controls:hover {
            opacity: 1;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(34, 197, 94, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
        }
        
        .notification.show {
            transform: translateX(0);
        }
        
        .notification.error {
            background: rgba(239, 68, 68, 0.9);
        }

        .intro-outro-preview {
            border-radius: 12px;
            overflow: hidden;
            background: rgba(51, 65, 85, 0.3);
        }
    </style>
</head>
<body>
    <div class="min-h-screen p-4 md:p-8">
        <div class="max-w-6xl mx-auto">
            <!-- Header -->
            <header class="mb-12 text-center">
                <h1 class="text-5xl font-bold fireship-gradient mb-4">
                    AI Video Studio
                </h1>
                <p class="text-xl text-slate-400 max-w-2xl mx-auto">
                    Create engaging Fireship-style videos with AI-generated scripts, meme images, and natural voiceovers
                </p>
            </header>

            <!-- Configuration Panel -->
            <div class="glass-card mb-8">
                <h3 class="text-lg font-semibold mb-4 flex items-center">
                    <span class="material-icons mr-2">settings</span>
                    API Configuration
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium mb-2">Gemini API Key</label>
                        <input type="password" id="geminiApiKey" class="input-field" 
                               placeholder="Enter your Gemini API key">
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2">Video Style</label>
                        <select id="videoStyle" class="input-field">
                            <option value="fireship">Fireship Style</option>
                            <option value="educational">Educational</option>
                            <option value="humorous">Humorous</option>
                            <option value="dramatic">Dramatic</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- Step 1: Video Idea -->
            <div class="glass-card mb-8" id="step1">
                <div class="flex items-center mb-6">
                    <div class="w-12 h-12 bg-gradient-to-r from-purple-500 to-pink-500 rounded-full flex items-center justify-center mr-4">
                        <span class="text-white font-bold">1</span>
                    </div>
                    <h2 class="text-2xl font-semibold">Enter Your Video Concept</h2>
                </div>
                
                <p class="text-slate-400 mb-6">
                    Describe your video idea in detail. The more specific you are, the better the AI can generate a Fireship-style script.
                </p>
                
                <div class="mb-6">
                    <textarea id="videoPrompt" class="input-field h-32 resize-none" 
                              placeholder="e.g., Explain WebAssembly in 100 seconds, why it's faster than JavaScript, and how it's changing web development..."></textarea>
                </div>
                
                <div class="flex justify-end">
                    <button class="btn-primary" id="btnGenerateScript" onclick="generateScript()">
                        <span class="material-icons mr-2">auto_awesome</span>
                        Generate Fireship Script
                    </button>
                </div>
            </div>

            <!-- Step 2: Script Review -->
            <div class="glass-card mb-8 hidden" id="step2">
                <div class="flex items-center mb-6">
                    <div class="w-12 h-12 bg-gradient-to-r from-blue-500 to-cyan-500 rounded-full flex items-center justify-center mr-4">
                        <span class="text-white font-bold">2</span>
                    </div>
                    <h2 class="text-2xl font-semibold">Review & Edit Script</h2>
                </div>
                
                <div class="mb-6">
                    <div class="flex justify-between items-center mb-4">
                        <label class="text-sm font-medium">Generated Script</label>
                        <div class="flex gap-2">
                            <button class="btn-secondary text-sm" onclick="regenerateScript()">
                                <span class="material-icons mr-1 text-sm">refresh</span>
                                Regenerate
                            </button>
                            <button class="btn-secondary text-sm" onclick="enhanceScript()">
                                <span class="material-icons mr-1 text-sm">tune</span>
                                Enhance
                            </button>
                        </div>
                    </div>
                    <textarea id="generatedScript" class="input-field h-64 resize-none font-mono text-sm"></textarea>
                </div>
                
                <div class="flex justify-between">
                    <button class="btn-secondary" onclick="goToStep(1)">
                        <span class="material-icons mr-2">arrow_back</span>
                        Back
                    </button>
                    <button class="btn-primary" onclick="goToStep('2b')">
                        <span class="material-icons mr-2">movie</span>
                        Setup Intro/Outro
                    </button>
                </div>
            </div>

            <!-- Step 2B: Intro & Outro Setup -->
            <div class="glass-card mb-8 hidden" id="step2b">
                <div class="flex items-center mb-6">
                    <div class="w-12 h-12 bg-gradient-to-r from-indigo-500 to-purple-500 rounded-full flex items-center justify-center mr-4">
                        <span class="text-white font-bold">2B</span>
                    </div>
                    <h2 class="text-2xl font-semibold">Intro & Outro Setup</h2>
                </div>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <!-- Intro Configuration -->
                    <div class="glass-card">
                        <h3 class="text-lg font-semibold mb-4 flex items-center">
                            <span class="material-icons mr-2">play_circle</span>
                            Video Intro
                        </h3>
                        <div class="space-y-4">
                            <div class="flex items-center">
                                <input type="checkbox" id="enableIntro" checked class="mr-2" onchange="updateIntroSettings()">
                                <label>Enable Intro</label>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Intro Text</label>
                                <input type="text" id="introText" class="input-field" 
                                       placeholder="Your Channel Name / Video Title" onchange="updateIntroSettings()">
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Duration (seconds)</label>
                                <input type="range" id="introDuration" min="2" max="5" value="3" class="w-full" 
                                       oninput="updateIntroDurationText(); updateIntroSettings()">
                                <span class="text-sm text-slate-400" id="introDurationText">3 seconds</span>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Animation Style</label>
                                <select id="introAnimation" class="input-field" onchange="updateIntroSettings()">
                                    <option value="fadeIn">Fade In</option>
                                    <option value="slideDown">Slide Down</option>
                                    <option value="zoomIn">Zoom In</option>
                                    <option value="typewriter">Typewriter</option>
                                </select>
                            </div>
                            <label class="btn-secondary cursor-pointer w-full">
                                <span class="material-icons mr-2">upload</span>
                                Upload Intro Image/Logo
                                <input type="file" accept="image/*" id="uploadIntroImage" class="hidden" onchange="handleIntroImageUpload(event)">
                            </label>
                            <div id="introPreview" class="hidden intro-outro-preview">
                                <img id="introImagePreview" class="w-full h-32 object-cover">
                            </div>
                        </div>
                    </div>
                    
                    <!-- Outro Configuration -->
                    <div class="glass-card">
                        <h3 class="text-lg font-semibold mb-4 flex items-center">
                            <span class="material-icons mr-2">stop_circle</span>
                            Video Outro
                        </h3>
                        <div class="space-y-4">
                            <div class="flex items-center">
                                <input type="checkbox" id="enableOutro" checked class="mr-2" onchange="updateOutroSettings()">
                                <label>Enable Outro</label>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Outro Text</label>
                                <textarea id="outroText" class="input-field h-20 resize-none"
                                          placeholder="Thanks for watching! Subscribe for more content!" onchange="updateOutroSettings()"></textarea>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Duration (seconds)</label>
                                <input type="range" id="outroDuration" min="3" max="6" value="4" class="w-full" 
                                       oninput="updateOutroDurationText(); updateOutroSettings()">
                                <span class="text-sm text-slate-400" id="outroDurationText">4 seconds</span>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Animation Style</label>
                                <select id="outroAnimation" class="input-field" onchange="updateOutroSettings()">
                                    <option value="slideUp">Slide Up</option>
                                    <option value="fadeIn">Fade In</option>
                                    <option value="bounceIn">Bounce In</option>
                                    <option value="expandIn">Expand In</option>
                                </select>
                            </div>
                            <label class="btn-secondary cursor-pointer w-full">
                                <span class="material-icons mr-2">upload</span>
                                Upload Outro Background
                                <input type="file" accept="image/*" id="uploadOutroImage" class="hidden" onchange="handleOutroImageUpload(event)">
                            </label>
                            <div id="outroPreview" class="hidden intro-outro-preview">
                                <img id="outroImagePreview" class="w-full h-32 object-cover">
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="flex justify-between mt-8">
                    <button class="btn-secondary" onclick="goToStep(2)">
                        <span class="material-icons mr-2">arrow_back</span>
                        Back
                    </button>
                    <button class="btn-primary" onclick="goToStep(3)">
                        <span class="material-icons mr-2">image</span>
                        Continue to Images
                    </button>
                </div>
            </div>

            <!-- Step 3: Image Curation -->
            <div class="glass-card mb-8 hidden" id="step3">
                <div class="flex items-center mb-6">
                    <div class="w-12 h-12 bg-gradient-to-r from-green-500 to-emerald-500 rounded-full flex items-center justify-center mr-4">
                        <span class="text-white font-bold">3</span>
                    </div>
                    <h2 class="text-2xl font-semibold">Curate Visual Content</h2>
                </div>
                
                <!-- Enhanced settings -->
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div>
                        <label class="block text-sm font-medium mb-2">Transition Style</label>
                        <select id="transitionStyle" class="input-field" onchange="updateTransitionSettings()">
                            <option value="crossfade">Crossfade</option>
                            <option value="slide">Slide</option>
                            <option value="zoom">Zoom</option>
                            <option value="blur">Motion Blur</option>
                            <option value="wipe">Wipe</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2">Transition Duration</label>
                        <input type="range" id="transitionDuration" min="200" max="1000" value="500" class="w-full" 
                               oninput="updateTransitionDurationText(); updateTransitionSettings()">
                        <span class="text-sm text-slate-400" id="transitionDurationText">500ms</span>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-2">Caption Style</label>
                        <select id="captionStyle" class="input-field" onchange="updateCaptionSettings()">
                            <option value="fireship">Fireship Style</option>
                            <option value="minimal">Minimal</option>
                            <option value="bold">Bold</option>
                            <option value="typewriter">Typewriter</option>
                        </select>
                    </div>
                </div>
                
                <div class="mb-6">
                    <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4" id="imageGallery">
                        <!-- Images will be populated here -->
                    </div>
                </div>
                
                <div class="flex flex-wrap gap-4 mb-6">
                    <label class="btn-secondary cursor-pointer">
                        <span class="material-icons mr-2">add_photo_alternate</span>
                        Upload Custom Image
                        <input type="file" accept="image/*" id="uploadImage" class="hidden" onchange="handleImageUpload(event)">
                    </label>
                    <button class="btn-secondary" id="btnGenerateImages" onclick="generateImages()">
                        <span class="material-icons mr-2">image</span>
                        Generate Images
                    </button>
                    <button class="btn-secondary" onclick="generateMoreImages()">
                        <span class="material-icons mr-2">refresh</span>
                        Generate More
                    </button>
                </div>
                
                <div class="flex justify-between">
                    <button class="btn-secondary" onclick="goToStep('2b')">
                        <span class="material-icons mr-2">arrow_back</span>
                        Back
                    </button>
                    <button class="btn-primary" onclick="goToStep(4)">
                        <span class="material-icons mr-2">mic</span>
                        Add Voiceover
                    </button>
                </div>
            </div>

            <!-- Step 4: Voiceover & Preview -->
            <div class="glass-card mb-8 hidden" id="step4">
                <div class="flex items-center mb-6">
                    <div class="w-12 h-12 bg-gradient-to-r from-orange-500 to-red-500 rounded-full flex items-center justify-center mr-4">
                        <span class="text-white font-bold">4</span>
                    </div>
                    <h2 class="text-2xl font-semibold">Voiceover & Preview</h2>
                </div>
                
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <!-- Voice Settings -->
                    <div>
                        <h3 class="text-lg font-semibold mb-4">Voice Settings</h3>
                        <div class="space-y-4">
                            <div>
                                <label class="block text-sm font-medium mb-2">Voice Type</label>
                                <select id="voiceType" class="input-field" onchange="updateVoicePreview()">
                                    <!-- Populated by JavaScript -->
                                </select>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Speech Rate</label>
                                <input type="range" id="speechRate" min="0.5" max="2" step="0.1" value="1.2" class="w-full" onchange="updateVoiceSettings()">
                                <div class="flex justify-between text-xs text-slate-400">
                                    <span>Slow</span>
                                    <span>Normal</span>
                                    <span>Fast</span>
                                </div>
                            </div>
                            <div>
                                <label class="block text-sm font-medium mb-2">Voice Pitch</label>
                                <input type="range" id="voicePitch" min="0.5" max="2" step="0.1" value="1" class="w-full" onchange="updateVoiceSettings()">
                            </div>
                            <button class="btn-secondary w-full" onclick="testVoice()">
                                <span class="material-icons mr-2">play_arrow</span>
                                Test Voice
                            </button>
                        </div>
                    </div>
                    
                    <!-- Video Preview -->
                    <div>
                        <h3 class="text-lg font-semibold mb-4">Video Preview</h3>
                        <div class="video-preview mb-4" id="videoPreview">
                            <div class="overlay-controls" id="previewControls">
                                <button class="btn-primary mb-4" onclick="playPreview()">
                                    <span class="material-icons mr-2">play_arrow</span>
                                    Play Preview
                                </button>
                                <p class="text-sm text-slate-300">Click to preview your video</p>
                            </div>
                            <img id="previewImage" class="w-full h-full object-cover hidden" alt="Preview">
                            <canvas id="exportCanvas" class="w-full h-full hidden" width="1280" height="720"></canvas>
                        </div>
                        
                        <div class="flex gap-2">
                            <button class="btn-primary flex-1" onclick="playFullPreview()">
                                <span class="material-icons mr-2">play_circle</span>
                                Full Preview
                            </button>
                            <button class="btn-secondary" onclick="stopPreview()">
                                <span class="material-icons">stop</span>
                            </button>
                        </div>
                    </div>
                </div>
                
                <div class="flex justify-between mt-8">
                    <button class="btn-secondary" onclick="goToStep(3)">
                        <span class="material-icons mr-2">arrow_back</span>
                        Back
                    </button>
                    <button class="btn-primary" id="btnExport" onclick="exportVideo()">
                        <span class="material-icons mr-2">file_download</span>
                        Export Video
                    </button>
                </div>
            </div>

            <!-- Progress Bar -->
            <div class="glass-card">
                <div class="flex justify-between items-center mb-4">
                    <span class="text-sm font-medium">Progress</span>
                    <span class="text-sm text-slate-400" id="progressText">Step 1 of 4</span>
                </div>
                <div class="progress-container">
                    <div class="progress-fill" id="progressBar" style="width: 25%"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div id="notification" class="notification">
        <span id="notificationText"></span>
    </div>

    <script>
        // Application State
        let currentStep = 1;
        let videoData = {
            prompt: '',
            script: '',
            scenes: [],
            selectedVoice: null,
            speechRate: 1.2,
            voicePitch: 1,
            intro: {
                enabled: true,
                duration: 3000,
                imageUrl: null,
                localImageFile: null,
                text: '',
                animation: 'fadeIn'
            },
            outro: {
                enabled: true,
                duration: 4000,
                imageUrl: null,
                localImageFile: null,
                text: 'Thanks for watching! Subscribe for more!',
                animation: 'slideUp'
            },
            transitions: {
                type: 'crossfade',
                duration: 500
            },
            captions: {
                enabled: true,
                style: 'fireship',
                position: 'bottom'
            }
        };
        
        let isPlaying = false;
        let currentScene = 0;
        let mediaRecorder = null;
        let recordedChunks = [];

        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            initializeVoices();
            updateProgress();
            loadSavedData();
            initializeEventListeners();
        });

        function initializeEventListeners() {
            // Initialize duration text updates
            updateIntroDurationText();
            updateOutroDurationText();
            updateTransitionDurationText();
        }

        // Utility Functions
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            const text = document.getElementById('notificationText');
            
            text.textContent = message;
            notification.className = `notification ${type} show`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function showLoading(buttonId, text = 'Processing...') {
            const button = document.getElementById(buttonId);
            if (button) {
                button.disabled = true;
                button.innerHTML = `<span class="spinner"></span>${text}`;
            }
        }

        function hideLoading(buttonId, originalText) {
            const button = document.getElementById(buttonId);
            if (button) {
                button.disabled = false;
                button.innerHTML = originalText;
            }
        }

        function saveData() {
            localStorage.setItem('aiVideoStudio', JSON.stringify(videoData));
        }

        function loadSavedData() {
            const saved = localStorage.getItem('aiVideoStudio');
            if (saved) {
                try {
                    const savedData = JSON.parse(saved);
                    videoData = { ...videoData, ...savedData };
                    
                    if (videoData.prompt) {
                        document.getElementById('videoPrompt').value = videoData.prompt;
                    }
                    if (videoData.script) {
                        document.getElementById('generatedScript').value = videoData.script;
                    }
                    if (videoData.intro.text) {
                        document.getElementById('introText').value = videoData.intro.text;
                    }
                    if (videoData.outro.text) {
                        document.getElementById('outroText').value = videoData.outro.text;
                    }
                } catch (error) {
                    console.error('Error loading saved data:', error);
                }
            }
        }

        // Step Navigation
        function goToStep(step) {
            // Hide current step
            const currentStepElement = document.getElementById(`step${currentStep}`);
            if (currentStepElement) {
                currentStepElement.classList.add('hidden');
            }
            
            // Show target step
            const targetStepElement = document.getElementById(`step${step}`);
            if (targetStepElement) {
                targetStepElement.classList.remove('hidden');
            }
            
            currentStep = step;
            updateProgress();
            
            // Step-specific initialization
            if (step === 4) {
                initializeVoices();
            }
        }

        function updateProgress() {
            let progressValue = 25;
            let stepText = 'Step 1 of 4';
            
            switch (currentStep) {
                case 1:
                    progressValue = 25;
                    stepText = 'Step 1 of 4';
                    break;
                case 2:
                    progressValue = 40;
                    stepText = 'Step 2 of 4';
                    break;
                case '2b':
                    progressValue = 55;
                    stepText = 'Step 2B of 4';
                    break;
                case 3:
                    progressValue = 75;
                    stepText = 'Step 3 of 4';
                    break;
                case 4:
                    progressValue = 100;
                    stepText = 'Step 4 of 4';
                    break;
            }
            
            document.getElementById('progressBar').style.width = `${progressValue}%`;
            document.getElementById('progressText').textContent = stepText;
        }

        // Settings Update Functions
        function updateIntroDurationText() {
            const duration = document.getElementById('introDuration').value;
            document.getElementById('introDurationText').textContent = `${duration} seconds`;
        }

        function updateOutroDurationText() {
            const duration = document.getElementById('outroDuration').value;
            document.getElementById('outroDurationText').textContent = `${duration} seconds`;
        }

        function updateTransitionDurationText() {
            const duration = document.getElementById('transitionDuration').value;
            document.getElementById('transitionDurationText').textContent = `${duration}ms`;
        }

        function updateIntroSettings() {
            videoData.intro.enabled = document.getElementById('enableIntro').checked;
            videoData.intro.text = document.getElementById('introText').value;
            videoData.intro.duration = parseInt(document.getElementById('introDuration').value) * 1000;
            videoData.intro.animation = document.getElementById('introAnimation').value;
            saveData();
        }

        function updateOutroSettings() {
            videoData.outro.enabled = document.getElementById('enableOutro').checked;
            videoData.outro.text = document.getElementById('outroText').value;
            videoData.outro.duration = parseInt(document.getElementById('outroDuration').value) * 1000;
            videoData.outro.animation = document.getElementById('outroAnimation').value;
            saveData();
        }

        function updateTransitionSettings() {
            videoData.transitions.type = document.getElementById('transitionStyle').value;
            videoData.transitions.duration = parseInt(document.getElementById('transitionDuration').value);
            saveData();
        }

        function updateCaptionSettings() {
            videoData.captions.style = document.getElementById('captionStyle').value;
            saveData();
        }

        function updateVoiceSettings() {
            videoData.speechRate = parseFloat(document.getElementById('speechRate').value);
            videoData.voicePitch = parseFloat(document.getElementById('voicePitch').value);
            saveData();
        }

        function handleIntroImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                videoData.intro.localImageFile = file;
                const preview = document.getElementById('introPreview');
                const img = document.getElementById('introImagePreview');
                img.src = URL.createObjectURL(file);
                preview.classList.remove('hidden');
                saveData();
                showNotification('Intro image uploaded successfully!');
            }
        }

        function handleOutroImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                videoData.outro.localImageFile = file;
                const preview = document.getElementById('outroPreview');
                const img = document.getElementById('outroImagePreview');
                img.src = URL.createObjectURL(file);
                preview.classList.remove('hidden');
                saveData();
                showNotification('Outro image uploaded successfully!');
            }
        }

        // Script Generation with Gemini API
        async function generateScript() {
            const prompt = document.getElementById('videoPrompt').value.trim();
            const apiKey = document.getElementById('geminiApiKey').value.trim();
            const style = document.getElementById('videoStyle').value;
            
            if (!prompt) {
                showNotification('Please enter a video concept', 'error');
                return;
            }
            
            if (!apiKey) {
                showNotification('Please enter your Gemini API key', 'error');
                return;
            }

            showLoading('btnGenerateScript', 'Generating Fireship Script...');
            
            try {
                const fireshipPrompt = `Create a Fireship-style video script for: "${prompt}"

Style Guidelines:
- ${style} tone with quick wit and humor
- Fast-paced, engaging narration 
- Include meme references and developer humor
- Keep scenes short (10-15 seconds each)
- Use technical accuracy with casual delivery
- Add surprising facts or "plot twists"
- Include call-to-action at the end

Format each scene exactly like this:
[SCENE X]
VISUAL: Brief description of the visual/meme needed
NARRATOR: The exact text to be spoken (conversational, punchy)

Create 5-8 scenes total. Make it entertaining and informative like Fireship's "X in 100 seconds" videos.`;

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: fireshipPrompt
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.8,
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 2048,
                        }
                    })
                });

                const data = await response.json();
                
                if (data.candidates && data.candidates[0]) {
                    const script = data.candidates[0].content.parts[0].text;
                    document.getElementById('generatedScript').value = script;
                    videoData.prompt = prompt;
                    videoData.script = script;
                    saveData();
                    
                    showNotification('Fireship-style script generated successfully!');
                    goToStep(2);
                } else {
                    throw new Error('Failed to generate script');
                }
                
            } catch (error) {
                console.error('Script generation error:', error);
                showNotification('Failed to generate script. Check your API key.', 'error');
            }
            
            hideLoading('btnGenerateScript', '<span class="material-icons mr-2">auto_awesome</span>Generate Fireship Script');
        }

        async function regenerateScript() {
            await generateScript();
        }

        async function enhanceScript() {
            const currentScript = document.getElementById('generatedScript').value;
            const apiKey = document.getElementById('geminiApiKey').value.trim();
            
            if (!currentScript || !apiKey) return;
            
            showLoading('btnGenerateScript', 'Enhancing Script...');
            
            try {
                const enhancePrompt = `Enhance this Fireship-style video script to be more engaging, funnier, and technically accurate. Keep the same format but improve the humor, add more meme references, and make the narration more punchy:

${currentScript}

Make it more like Fireship's signature style with:
- Better jokes and meme references
- More surprising technical insights
- Improved pacing and flow
- Stronger hook and conclusion`;

                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-lite:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        contents: [{
                            parts: [{
                                text: enhancePrompt
                            }]
                        }],
                        generationConfig: {
                            temperature: 0.9,
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 2048,
                        }
                    })
                });

                const data = await response.json();
                
                if (data.candidates && data.candidates[0]) {
                    const enhancedScript = data.candidates[0].content.parts[0].text;
                    document.getElementById('generatedScript').value = enhancedScript;
                    videoData.script = enhancedScript;
                    saveData();
                    showNotification('Script enhanced successfully!');
                }
                
            } catch (error) {
                console.error('Script enhancement error:', error);
                showNotification('Failed to enhance script', 'error');
            }
            
            hideLoading('btnGenerateScript', '<span class="material-icons mr-2">auto_awesome</span>Generate Fireship Script');
        }

        // Image Generation
        async function generateImages() {
            const script = document.getElementById('generatedScript').value;
            if (!script) {
                showNotification('No script available for image generation', 'error');
                return;
            }

            showLoading('btnGenerateImages', 'Generating Images...');
            
            try {
                videoData.scenes = parseScriptToScenes(script);
                
                for (let i = 0; i < videoData.scenes.length; i++) {
                    const scene = videoData.scenes[i];
                    
                    // Update progress
                    const progress = Math.round(((i + 1) / videoData.scenes.length) * 100);
                    document.getElementById('btnGenerateImages').innerHTML = 
                        `<span class="spinner"></span>Generating Images ${progress}%`;
                    
                    await generateImageForScene(scene, i);
                    
                    // Small delay to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                
                renderImageGallery();
                saveData();
                showNotification('Images generated successfully!');
                
            } catch (error) {
                console.error('Image generation error:', error);
                showNotification('Failed to generate some images', 'error');
            }
            
            hideLoading('btnGenerateImages', '<span class="material-icons mr-2">image</span>Generate Images');
        }

        async function generateImageForScene(scene, index) {
            const keywords = extractKeywords(scene.visual);
            
            try {
                // Try Imgflip API first
                const imgflipResponse = await fetch('https://api.imgflip.com/get_memes');
                const imgflipData = await imgflipResponse.json();
                
                if (imgflipData.success && imgflipData.data.memes.length > 0) {
                    const relevantMeme = findRelevantMeme(imgflipData.data.memes, keywords);
                    scene.imageUrl = relevantMeme.url;
                    scene.imageSource = 'imgflip';
                    return;
                }
            } catch (error) {
                console.log('Imgflip API failed, trying alternatives...');
            }
            
            try {
                // Fallback to Reddit meme API
                const redditResponse = await fetch('https://meme-api.com/gimme');
                const redditData = await redditResponse.json();
                
                if (redditData && redditData.url) {
                    scene.imageUrl = redditData.url;
                    scene.imageSource = 'reddit';
                    return;
                }
            } catch (error) {
                console.log('Reddit API failed, using placeholder...');
            }
            
            // Final fallback
            scene.imageUrl = `https://via.placeholder.com/800x600/1E293B/E2E8F0?text=Scene+${index + 1}`;
            scene.imageSource = 'placeholder';
        }

        function extractKeywords(visual) {
            return visual.toLowerCase()
                .split(' ')
                .filter(word => word.length > 3)
                .slice(0, 3)
                .join(' ');
        }

        function findRelevantMeme(memes, keywords) {
            const searchTerms = keywords.toLowerCase().split(' ');
            
            // Try to find relevant meme
            for (const meme of memes) {
                const memeName = meme.name.toLowerCase();
                if (searchTerms.some(term => memeName.includes(term))) {
                    return meme;
                }
            }
            
            // Return random meme if no match
            return memes[Math.floor(Math.random() * memes.length)];
        }

        function parseScriptToScenes(script) {
            const sceneRegex = /\[SCENE\s*(\d+)\]\s*VISUAL:\s*(.*?)\s*NARRATOR:\s*(.*?)(?=\s*\[SCENE|\s*$)/gis;
            const scenes = [];
            let match;
            
            while ((match = sceneRegex.exec(script)) !== null) {
                scenes.push({
                    sceneNum: parseInt(match[1]),
                    visual: match[2].trim(),
                    narrator: match[3].trim(),
                    imageUrl: null,
                    localImageFile: null,
                    imageSource: null,
                    duration: estimateDuration(match[3].trim())
                });
            }
            
            return scenes;
        }

        function estimateDuration(text) {
            // Estimate duration based on text length (average reading speed)
            const wordsPerMinute = 180; // Fast Fireship pace
            const words = text.split(' ').length;
            return Math.max(2000, (words / wordsPerMinute) * 60 * 1000); // Minimum 2 seconds
        }

        function renderImageGallery() {
            const gallery = document.getElementById('imageGallery');
            gallery.innerHTML = '';
            
            videoData.scenes.forEach((scene, index) => {
                const sceneCard = document.createElement('div');
                sceneCard.className = 'scene-card group cursor-pointer';
                sceneCard.dataset.sceneIndex = index;
                
                sceneCard.innerHTML = `
                    <img src="${scene.localImageFile ? URL.createObjectURL(scene.localImageFile) : (scene.imageUrl || 'https://via.placeholder.com/400')}" 
                         alt="Scene ${scene.sceneNum}" 
                         class="w-full h-full object-cover">
                    <div class="absolute inset-0 bg-black bg-opacity-60 opacity-0 group-hover:opacity-100 transition-opacity flex flex-col justify-center items-center p-4">
                        <p class="text-white text-sm text-center mb-3">Scene ${scene.sceneNum}</p>
                        <p class="text-slate-300 text-xs text-center mb-4">${scene.visual.substring(0, 50)}...</p>
                        <div class="flex gap-2">
                            <button onclick="replaceImage(${index})" class="btn-secondary text-xs py-1 px-2">
                                <span class="material-icons text-sm">edit</span>
                            </button>
                            <button onclick="removeImage(${index})" class="btn-secondary text-xs py-1 px-2">
                                <span class="material-icons text-sm">delete</span>
                            </button>
                        </div>
                    </div>
                `;
                
                gallery.appendChild(sceneCard);
            });
        }

        async function generateMoreImages() {
            showLoading('btnGenerateImages', 'Generating More Images...');
            
            for (let i = 0; i < videoData.scenes.length; i++) {
                if (!videoData.scenes[i].imageUrl || videoData.scenes[i].imageSource === 'placeholder') {
                    await generateImageForScene(videoData.scenes[i], i);
                }
            }
            
            renderImageGallery();
            saveData();
            hideLoading('btnGenerateImages', '<span class="material-icons mr-2">image</span>Generate Images');
            showNotification('Additional images generated!');
        }

        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // For now, add to first available slot
            const emptySceneIndex = videoData.scenes.findIndex(scene => !scene.imageUrl && !scene.localImageFile);
            
            if (emptySceneIndex !== -1) {
                videoData.scenes[emptySceneIndex].localImageFile = file;
                videoData.scenes[emptySceneIndex].imageUrl = null;
                renderImageGallery();
                saveData();
                showNotification('Custom image uploaded successfully!');
            } else {
                showNotification('All scene slots are filled', 'error');
            }
        }

        function replaceImage(sceneIndex) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'image/*';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    videoData.scenes[sceneIndex].localImageFile = file;
                    videoData.scenes[sceneIndex].imageUrl = null;
                    renderImageGallery();
                    saveData();
                    showNotification('Image replaced successfully!');
                }
            };
            input.click();
        }

        function removeImage(sceneIndex) {
            if (confirm('Remove this image?')) {
                videoData.scenes[sceneIndex].imageUrl = null;
                videoData.scenes[sceneIndex].localImageFile = null;
                renderImageGallery();
                saveData();
                showNotification('Image removed');
            }
        }

        // Voice and Audio Functions
        function initializeVoices() {
            const voiceSelect = document.getElementById('voiceType');
            voiceSelect.innerHTML = '<option value="">Loading voices...</option>';
            
            // ResponsiveVoice options
            if (typeof responsiveVoice !== 'undefined') {
                const rvVoices = [
                    'UK English Male',
                    'UK English Female', 
                    'US English Male',
                    'US English Female',
                    'Australian Male',
                    'Australian Female'
                ];
                
                voiceSelect.innerHTML = '';
                rvVoices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice;
                    option.textContent = `${voice} (ResponsiveVoice)`;
                    option.dataset.engine = 'responsivevoice';
                    voiceSelect.appendChild(option);
                });
            }
            
            // Browser voices as fallback
            const browserVoices = speechSynthesis.getVoices().filter(v => v.lang.startsWith('en'));
            if (browserVoices.length > 0) {
                if (voiceSelect.options.length > 0) {
                    const separator = document.createElement('option');
                    separator.disabled = true;
                    separator.textContent = '--- Browser Voices ---';
                    voiceSelect.appendChild(separator);
                }
                
                browserVoices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.name;
                    option.textContent = `${voice.name} (Browser)`;
                    option.dataset.engine = 'browser';
                    voiceSelect.appendChild(option);
                });
            }
            
            if (voiceSelect.options.length === 0) {
                voiceSelect.innerHTML = '<option value="">No voices available</option>';
            }
        }

        function updateVoicePreview() {
            const voiceSelect = document.getElementById('voiceType');
            videoData.selectedVoice = {
                name: voiceSelect.value,
                engine: voiceSelect.options[voiceSelect.selectedIndex]?.dataset.engine
            };
            saveData();
        }

        function testVoice() {
            const testText = "Hey developers! This is how your Fireship-style video will sound. Pretty cool, right?";
            speakText(testText);
        }

        function speakText(text, onEnd = null) {
            const rate = document.getElementById('speechRate').value;
            const pitch = document.getElementById('voicePitch').value;
            
            if (videoData.selectedVoice?.engine === 'responsivevoice' && typeof responsiveVoice !== 'undefined') {
                responsiveVoice.speak(text, videoData.selectedVoice.name, {
                    rate: rate,
                    pitch: pitch,
                    onend: onEnd
                });
            } else if (videoData.selectedVoice?.engine === 'browser') {
                const utterance = new SpeechSynthesisUtterance(text);
                const voice = speechSynthesis.getVoices().find(v => v.name === videoData.selectedVoice.name);
                if (voice) utterance.voice = voice;
                utterance.rate = rate;
                utterance.pitch = pitch;
                utterance.onend = onEnd;
                speechSynthesis.speak(utterance);
            }
        }

        // Video Preview and Export
        async function playPreview() {
            if (!videoData.scenes.length) {
                showNotification('No scenes available for preview', 'error');
                return;
            }
            
            if (!videoData.selectedVoice) {
                showNotification('Please select a voice first', 'error');
                return;
            }
            
            isPlaying = true;
            currentScene = 0;
            
            document.getElementById('previewControls').style.display = 'none';
            playScene(currentScene);
        }

        function playScene(sceneIndex) {
            if (!isPlaying || sceneIndex >= videoData.scenes.length) {
                stopPreview();
                return;
            }
            
            const scene = videoData.scenes[sceneIndex];
            const previewImage = document.getElementById('previewImage');
            
            // Show current scene image
            previewImage.src = scene.localImageFile ? 
                URL.createObjectURL(scene.localImageFile) : 
                (scene.imageUrl || 'https://via.placeholder.com/1280x720/1E293B/E2E8F0?text=Scene+' + (sceneIndex + 1));
            previewImage.classList.remove('hidden');
            
            // Speak the narration
            speakText(scene.narrator, () => {
                if (isPlaying) {
                    currentScene++;
                    playScene(currentScene);
                }
            });
        }

        function playFullPreview() {
            playPreview();
        }

        function stopPreview() {
            isPlaying = false;
            
            // Stop any ongoing speech
            if (typeof responsiveVoice !== 'undefined') {
                responsiveVoice.cancel();
            }
            speechSynthesis.cancel();
            
            // Reset preview
            document.getElementById('previewImage').classList.add('hidden');
            document.getElementById('previewControls').style.display = 'flex';
            currentScene = 0;
        }

        async function exportVideo() {
            if (!videoData.scenes.length) {
                showNotification('No scenes to export', 'error');
                return;
            }
            
            showLoading('btnExport', 'Preparing Export...');
            
            try {
                const canvas = document.getElementById('exportCanvas');
                const ctx = canvas.getContext('2d');
                canvas.classList.remove('hidden');
                
                // Setup MediaRecorder
                const stream = canvas.captureStream(30);
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm;codecs=vp9'
                });
                
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    downloadVideo(blob);
                    canvas.classList.add('hidden');
                    hideLoading('btnExport', '<span class="material-icons mr-2">file_download</span>Export Video');
                };
                
                mediaRecorder.start();
                
                // Render each scene
                for (let i = 0; i < videoData.scenes.length; i++) {
                    const scene = videoData.scenes[i];
                    
                    // Update progress
                    const progress = Math.round(((i + 1) / videoData.scenes.length) * 100);
                    document.getElementById('btnExport').innerHTML = 
                        `<span class="spinner"></span>Exporting ${progress}%`;
                    
                    await renderSceneToCanvas(scene, ctx, canvas);
                    await new Promise(resolve => setTimeout(resolve, scene.duration));
                }
                
                mediaRecorder.stop();
                
            } catch (error) {
                console.error('Export error:', error);
                showNotification('Export failed', 'error');
                hideLoading('btnExport', '<span class="material-icons mr-2">file_download</span>Export Video');
            }
        }

        async function renderSceneToCanvas(scene, ctx, canvas) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = () => {
                    // Clear canvas
                    ctx.fillStyle = '#1E293B';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Calculate aspect ratio
                    const canvasAspect = canvas.width / canvas.height;
                    const imgAspect = img.width / img.height;
                    
                    let drawWidth, drawHeight, offsetX, offsetY;
                    
                    if (imgAspect > canvasAspect) {
                        drawWidth = canvas.width;
                        drawHeight = drawWidth / imgAspect;
                        offsetX = 0;
                        offsetY = (canvas.height - drawHeight) / 2;
                    } else {
                        drawHeight = canvas.height;
                        drawWidth = drawHeight * imgAspect;
                        offsetY = 0;
                        offsetX = (canvas.width - drawWidth) / 2;
                    }
                    
                    ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
                    
                    // Add captions if enabled
                    if (videoData.captions.enabled && scene.narrator) {
                        renderCaption(ctx, canvas, scene.narrator, videoData.captions.style);
                    }
                    
                    resolve();
                };
                
                img.onerror = () => {
                    // Draw placeholder
                    ctx.fillStyle = '#334155';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#E2E8F0';
                    ctx.font = '48px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Scene ${scene.sceneNum}`, canvas.width/2, canvas.height/2);
                    resolve();
                };
                
                img.src = scene.localImageFile ? 
                    URL.createObjectURL(scene.localImageFile) : 
                    (scene.imageUrl || '');
            });
        }

        function renderCaption(ctx, canvas, text, style) {
            if (!text) return;
            
            const words = text.split(' ');
            const maxWordsPerLine = 8;
            const lines = [];
            
            for (let i = 0; i < words.length; i += maxWordsPerLine) {
                lines.push(words.slice(i, i + maxWordsPerLine).join(' '));
            }
            
            ctx.save();
            
            const fontSize = 32;
            const lineHeight = fontSize * 1.2;
            
            ctx.font = `bold ${fontSize}px Inter, sans-serif`;
            ctx.textAlign = 'center';
            
            const startY = canvas.height - (lines.length * lineHeight + 40);
            
            lines.forEach((line, index) => {
                const y = startY + (index * lineHeight);
                
                // Draw background with gradient
                const textWidth = ctx.measureText(line).width;
                const padding = 20;
                
                const gradient = ctx.createLinearGradient(
                    canvas.width/2 - textWidth/2 - padding, y - fontSize/2,
                    canvas.width/2 + textWidth/2 + padding, y + fontSize/2
                );
                gradient.addColorStop(0, 'rgba(99, 102, 241, 0.9)');
                gradient.addColorStop(1, 'rgba(139, 92, 246, 0.9)');
                
                ctx.fillStyle = gradient;
                roundRect(ctx, 
                    canvas.width/2 - textWidth/2 - padding,
                    y - fontSize/2 - 10,
                    textWidth + padding * 2,
                    fontSize + 20,
                    10
                );
                ctx.fill();
                
                // Draw text with shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillText(line, canvas.width/2 + 2, y + 2);
                
                ctx.fillStyle = '#FFFFFF';
                ctx.fillText(line, canvas.width/2, y);
            });
            
            ctx.restore();
        }

        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                        ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function downloadVideo(blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `fireship-style-video-${Date.now()}.webm`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            showNotification('Video exported successfully!');
        }

        // Enhanced Video Renderer Class
        class VideoRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.currentScene = 0;
                this.transitionProgress = 0;
                this.isTransitioning = false;
            }
            
            async renderSceneWithTransition(scene, nextScene, transitionType, duration) {
                this.isTransitioning = true;
                const startTime = Date.now();
                
                return new Promise((resolve) => {
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        this.transitionProgress = Math.min(elapsed / duration, 1);
                        
                        this.clearCanvas();
                        
                        switch (transitionType) {
                            case 'crossfade':
                                this.renderCrossfade(scene, nextScene);
                                break;
                            case 'slide':
                                this.renderSlideTransition(scene, nextScene);
                                break;
                            case 'zoom':
                                this.renderZoomTransition(scene, nextScene);
                                break;
                            case 'blur':
                                this.renderBlurTransition(scene, nextScene);
                                break;
                            case 'wipe':
                                this.renderWipeTransition(scene, nextScene);
                                break;
                            default:
                                this.renderCrossfade(scene, nextScene);
                        }
                        
                        if (this.transitionProgress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            this.isTransitioning = false;
                            resolve();
                        }
                    };
                    
                    animate();
                });
            }
            
            renderCrossfade(currentScene, nextScene) {
                // Draw current scene with decreasing opacity
                this.ctx.globalAlpha = 1 - this.transitionProgress;
                this.drawSceneImage(currentScene);
                
                // Draw next scene with increasing opacity
                this.ctx.globalAlpha = this.transitionProgress;
                this.drawSceneImage(nextScene);
                
                this.ctx.globalAlpha = 1;
            }
            
            renderSlideTransition(currentScene, nextScene) {
                const slideOffset = this.canvas.width * this.transitionProgress;
                
                // Draw current scene sliding out
                this.ctx.save();
                this.ctx.translate(-slideOffset, 0);
                this.drawSceneImage(currentScene);
                this.ctx.restore();
                
                // Draw next scene sliding in
                this.ctx.save();
                this.ctx.translate(this.canvas.width - slideOffset, 0);
                this.drawSceneImage(nextScene);
                this.ctx.restore();
            }
            
            renderZoomTransition(currentScene, nextScene) {
                const scale = 1 + this.transitionProgress;
                const alpha = 1 - this.transitionProgress;
                
                // Draw current scene zooming out
                this.ctx.save();
                this.ctx.globalAlpha = alpha;
                this.ctx.translate(this.canvas.width / 2, this.canvas.height / 2);
                this.ctx.scale(scale, scale);
                this.ctx.translate(-this.canvas.width / 2, -this.canvas.height / 2);
                this.drawSceneImage(currentScene);
                this.ctx.restore();
                
                // Draw next scene fading in
                this.ctx.globalAlpha = this.transitionProgress;
                this.drawSceneImage(nextScene);
                this.ctx.globalAlpha = 1;
            }
            
            renderBlurTransition(currentScene, nextScene) {
                // Apply blur effect during transition
                const blurAmount = Math.sin(this.transitionProgress * Math.PI) * 10;
                
                if (this.transitionProgress < 0.5) {
                    this.ctx.filter = `blur(${blurAmount}px)`;
                    this.drawSceneImage(currentScene);
                } else {
                    this.ctx.filter = `blur(${10 - blurAmount}px)`;
                    this.drawSceneImage(nextScene);
                }
                
                this.ctx.filter = 'none';
            }
            
            renderWipeTransition(currentScene, nextScene) {
                const wipePosition = this.canvas.width * this.transitionProgress;
                
                // Draw current scene
                this.drawSceneImage(currentScene);
                
                // Create clipping mask for next scene
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.rect(0, 0, wipePosition, this.canvas.height);
                this.ctx.clip();
                this.drawSceneImage(nextScene);
                this.ctx.restore();
            }
            
            drawSceneImage(scene) {
                if (!scene || !scene.imageUrl) return;
                
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                // For immediate rendering, we need to handle this synchronously
                if (scene.localImageFile) {
                    img.src = URL.createObjectURL(scene.localImageFile);
                } else {
                    img.src = scene.imageUrl;
                }
                
                // Calculate aspect ratio and draw
                const canvasAspect = this.canvas.width / this.canvas.height;
                const imgAspect = img.width / img.height || 1;
                
                let drawWidth, drawHeight, offsetX, offsetY;
                
                if (imgAspect > canvasAspect) {
                    drawWidth = this.canvas.width;
                    drawHeight = drawWidth / imgAspect;
                    offsetX = 0;
                    offsetY = (this.canvas.height - drawHeight) / 2;
                } else {
                    drawHeight = this.canvas.height;
                    drawWidth = drawHeight * imgAspect;
                    offsetY = 0;
                    offsetX = (this.canvas.width - drawWidth) / 2;
                }
                
                try {
                    this.ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
                } catch (error) {
                    // Fallback to placeholder
                    this.ctx.fillStyle = '#334155';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.fillStyle = '#E2E8F0';
                    this.ctx.font = '48px Inter';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText('Loading...', this.canvas.width/2, this.canvas.height/2);
                }
            }
            
            clearCanvas() {
                this.ctx.fillStyle = '#1E293B';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }

        // Enhanced Caption Renderer Class
        class CaptionRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.style = 'fireship';
                this.position = 'bottom';
            }
            
            renderCaption(text, style = this.style, position = this.position) {
                if (!text) return;
                
                const words = text.split(' ');
                const maxWordsPerLine = 8;
                const lines = [];
                
                for (let i = 0; i < words.length; i += maxWordsPerLine) {
                    lines.push(words.slice(i, i + maxWordsPerLine).join(' '));
                }
                
                this.ctx.save();
                
                switch (style) {
                    case 'fireship':
                        this.renderFireshipStyle(lines, position);
                        break;
                    case 'minimal':
                        this.renderMinimalStyle(lines, position);
                        break;
                    case 'bold':
                        this.renderBoldStyle(lines, position);
                        break;
                    case 'typewriter':
                        this.renderTypewriterStyle(lines, position);
                        break;
                }
                
                this.ctx.restore();
            }
            
            renderFireshipStyle(lines, position) {
                const fontSize = 32;
                const lineHeight = fontSize * 1.2;
                
                this.ctx.font = `bold ${fontSize}px Inter, sans-serif`;
                this.ctx.textAlign = 'center';
                
                const startY = position === 'bottom' ? 
                    this.canvas.height - (lines.length * lineHeight + 40) :
                    60;
                
                lines.forEach((line, index) => {
                    const y = startY + (index * lineHeight);
                    
                    // Draw background with gradient
                    const textWidth = this.ctx.measureText(line).width;
                    const padding = 20;
                    
                    const gradient = this.ctx.createLinearGradient(
                        this.canvas.width/2 - textWidth/2 - padding, y - fontSize/2,
                        this.canvas.width/2 + textWidth/2 + padding, y + fontSize/2
                    );
                    gradient.addColorStop(0, 'rgba(99, 102, 241, 0.9)');
                    gradient.addColorStop(1, 'rgba(139, 92, 246, 0.9)');
                    
                    this.ctx.fillStyle = gradient;
                    this.roundRect(
                        this.canvas.width/2 - textWidth/2 - padding,
                        y - fontSize/2 - 10,
                        textWidth + padding * 2,
                        fontSize + 20,
                        10
                    );
                    this.ctx.fill();
                    
                    // Draw text with shadow
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    this.ctx.fillText(line, this.canvas.width/2 + 2, y + 2);
                    
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText(line, this.canvas.width/2, y);
                });
            }
            
            renderMinimalStyle(lines, position) {
                const fontSize = 28;
                const lineHeight = fontSize * 1.3;
                
                this.ctx.font = `${fontSize}px Inter, sans-serif`;
                this.ctx.textAlign = 'center';
                
                const startY = position === 'bottom' ? 
                    this.canvas.height - (lines.length * lineHeight + 20) :
                    40;
                
                lines.forEach((line, index) => {
                    const y = startY + (index * lineHeight);
                    
                    // Simple background
                    const textWidth = this.ctx.measureText(line).width;
                    const padding = 15;
                    
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.roundRect(
                        this.canvas.width/2 - textWidth/2 - padding,
                        y - fontSize/2 - 5,
                        textWidth + padding * 2,
                        fontSize + 10,
                        5
                    );
                    this.ctx.fill();
                    
                    // White text
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText(line, this.canvas.width/2, y);
                });
            }
            
            renderBoldStyle(lines, position) {
                const fontSize = 36;
                const lineHeight = fontSize * 1.2;
                
                this.ctx.font = `bold ${fontSize}px Inter, sans-serif`;
                this.ctx.textAlign = 'center';
                
                const startY = position === 'bottom' ? 
                    this.canvas.height - (lines.length * lineHeight + 40) :
                    60;
                
                lines.forEach((line, index) => {
                    const y = startY + (index * lineHeight);
                    
                    // Bold background
                    const textWidth = this.ctx.measureText(line).width;
                    const padding = 25;
                    
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    this.roundRect(
                        this.canvas.width/2 - textWidth/2 - padding,
                        y - fontSize/2 - 10,
                        textWidth + padding * 2,
                        fontSize + 20,
                        8
                    );
                    this.ctx.fill();
                    
                    // Bold text with outline
                    this.ctx.strokeStyle = '#000000';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeText(line, this.canvas.width/2, y);
                    
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.fillText(line, this.canvas.width/2, y);
                });
            }
            
            renderTypewriterStyle(lines, position) {
                const fontSize = 30;
                const lineHeight = fontSize * 1.3;
                
                this.ctx.font = `${fontSize}px 'Courier New', monospace`;
                this.ctx.textAlign = 'center';
                
                const startY = position === 'bottom' ? 
                    this.canvas.height - (lines.length * lineHeight + 30) :
                    50;
                
                lines.forEach((line, index) => {
                    const y = startY + (index * lineHeight);
                    
                    // Typewriter background
                    const textWidth = this.ctx.measureText(line).width;
                    const padding = 20;
                    
                    this.ctx.fillStyle = 'rgba(20, 20, 20, 0.9)';
                    this.ctx.fillRect(
                        this.canvas.width/2 - textWidth/2 - padding,
                        y - fontSize/2 - 8,
                        textWidth + padding * 2,
                        fontSize + 16
                    );
                    
                    // Green terminal text
                    this.ctx.fillStyle = '#00FF00';
                    this.ctx.fillText(line, this.canvas.width/2, y);
                });
            }
            
            roundRect(x, y, width, height, radius) {
                this.ctx.beginPath();
                this.ctx.moveTo(x + radius, y);
                this.ctx.lineTo(x + width - radius, y);
                this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                this.ctx.lineTo(x + width, y + height - radius);
                this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                this.ctx.lineTo(x + radius, y + height);
                this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                this.ctx.lineTo(x, y + radius);
                this.ctx.quadraticCurveTo(x, y, x + radius, y);
                this.ctx.closePath();
            }
        }

        // Enhanced Export with Intro/Outro
        async function exportEnhancedVideo() {
            if (!videoData.scenes.length) {
                showNotification('No scenes to export', 'error');
                return;
            }
            
            showLoading('btnExport', 'Preparing Enhanced Export...');
            
            try {
                const canvas = document.getElementById('exportCanvas');
                const renderer = new VideoRenderer(canvas);
                const captionRenderer = new CaptionRenderer(canvas);
                
                canvas.classList.remove('hidden');
                
                // Setup MediaRecorder with higher quality
                const stream = canvas.captureStream(60);
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm;codecs=vp9',
                    videoBitsPerSecond: 5000000 // 5 Mbps for better quality
                });
                
                recordedChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    downloadVideo(blob);
                    canvas.classList.add('hidden');
                    hideLoading('btnExport', '<span class="material-icons mr-2">file_download</span>Export Video');
                };
                
                mediaRecorder.start();
                
                // 1. Render intro if enabled
                if (videoData.intro.enabled) {
                    await renderIntroSequence(renderer, captionRenderer);
                }
                
                // 2. Render main content with transitions
                for (let i = 0; i < videoData.scenes.length; i++) {
                    const scene = videoData.scenes[i];
                    const nextScene = videoData.scenes[i + 1];
                    
                    // Update progress
                    const totalSteps = videoData.scenes.length + 
                        (videoData.intro.enabled ? 1 : 0) + 
                        (videoData.outro.enabled ? 1 : 0);
                    const currentStep = i + (videoData.intro.enabled ? 2 : 1);
                    const progress = Math.round((currentStep / totalSteps) * 100);
                    
                    document.getElementById('btnExport').innerHTML = 
                        `<span class="spinner"></span>Exporting ${progress}%`;
                    
                    // Render scene with captions
                    await renderSceneWithCaptions(renderer, captionRenderer, scene);
                    
                    // Add transition to next scene if not last
                    if (nextScene && videoData.transitions.type !== 'none') {
                        await renderer.renderSceneWithTransition(
                            scene, 
                            nextScene, 
                            videoData.transitions.type, 
                            videoData.transitions.duration
                        );
                    }
                }
                
                // 3. Render outro if enabled
                if (videoData.outro.enabled) {
                    await renderOutroSequence(renderer, captionRenderer);
                }
                
                mediaRecorder.stop();
                
            } catch (error) {
                console.error('Enhanced export error:', error);
                showNotification('Export failed', 'error');
                hideLoading('btnExport', '<span class="material-icons mr-2">file_download</span>Export Video');
            }
        }

        async function renderIntroSequence(renderer, captionRenderer) {
            return new Promise((resolve) => {
                renderer.clearCanvas();
                
                // Draw intro background
                if (videoData.intro.localImageFile) {
                    const img = new Image();
                    img.onload = () => {
                        renderer.ctx.drawImage(img, 0, 0, renderer.canvas.width, renderer.canvas.height);
                        captionRenderer.renderCaption(videoData.intro.text, 'fireship', 'center');
                        setTimeout(resolve, videoData.intro.duration);
                    };
                    img.src = URL.createObjectURL(videoData.intro.localImageFile);
                } else {
                    // Default intro background
                    const gradient = renderer.ctx.createLinearGradient(0, 0, renderer.canvas.width, renderer.canvas.height);
                    gradient.addColorStop(0, '#6366F1');
                    gradient.addColorStop(1, '#8B5CF6');
                    renderer.ctx.fillStyle = gradient;
                    renderer.ctx.fillRect(0, 0, renderer.canvas.width, renderer.canvas.height);
                    
                    captionRenderer.renderCaption(videoData.intro.text, 'fireship', 'center');
                    setTimeout(resolve, videoData.intro.duration);
                }
            });
        }

        async function renderOutroSequence(renderer, captionRenderer) {
            return new Promise((resolve) => {
                renderer.clearCanvas();
                
                // Draw outro background
                if (videoData.outro.localImageFile) {
                    const img = new Image();
                    img.onload = () => {
                        renderer.ctx.drawImage(img, 0, 0, renderer.canvas.width, renderer.canvas.height);
                        captionRenderer.renderCaption(videoData.outro.text, 'fireship', 'center');
                        setTimeout(resolve, videoData.outro.duration);
                    };
                    img.src = URL.createObjectURL(videoData.outro.localImageFile);
                } else {
                    // Default outro background
                    const gradient = renderer.ctx.createLinearGradient(0, 0, renderer.canvas.width, renderer.canvas.height);
                    gradient.addColorStop(0, '#1E293B');
                    gradient.addColorStop(1, '#334155');
                    renderer.ctx.fillStyle = gradient;
                    renderer.ctx.fillRect(0, 0, renderer.canvas.width, renderer.canvas.height);
                    
                    captionRenderer.renderCaption(videoData.outro.text, 'fireship', 'center');
                    setTimeout(resolve, videoData.outro.duration);
                }
            });
        }

        async function renderSceneWithCaptions(renderer, captionRenderer, scene) {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                img.onload = () => {
                    // Clear and draw scene
                    renderer.clearCanvas();
                    
                    // Calculate aspect ratio and draw
                    const canvasAspect = renderer.canvas.width / renderer.canvas.height;
                    const imgAspect = img.width / img.height;
                    
                    let drawWidth, drawHeight, offsetX, offsetY;
                    
                    if (imgAspect > canvasAspect) {
                        drawWidth = renderer.canvas.width;
                        drawHeight = drawWidth / imgAspect;
                        offsetX = 0;
                        offsetY = (renderer.canvas.height - drawHeight) / 2;
                    } else {
                        drawHeight = renderer.canvas.height;
                        drawWidth = drawHeight * imgAspect;
                        offsetY = 0;
                        offsetX = (renderer.canvas.width - drawWidth) / 2;
                    }
                    
                    renderer.ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
                    
                    // Add captions if enabled
                    if (videoData.captions.enabled && scene.narrator) {
                        captionRenderer.renderCaption(
                            scene.narrator, 
                            videoData.captions.style, 
                            videoData.captions.position
                        );
                    }
                    
                    // Hold scene for its duration
                    setTimeout(resolve, scene.duration);
                };
                
                img.onerror = () => {
                    // Draw placeholder and continue
                    renderer.clearCanvas();
                    renderer.ctx.fillStyle = '#334155';
                    renderer.ctx.fillRect(0, 0, renderer.canvas.width, renderer.canvas.height);
                    renderer.ctx.fillStyle = '#E2E8F0';
                    renderer.ctx.font = '48px Inter';
                    renderer.ctx.textAlign = 'center';
                    renderer.ctx.fillText(`Scene ${scene.sceneNum}`, renderer.canvas.width/2, renderer.canvas.height/2);
                    setTimeout(resolve, scene.duration);
                };
                
                img.src = scene.localImageFile ? 
                    URL.createObjectURL(scene.localImageFile) : 
                    (scene.imageUrl || '');
            });
        }

        // Initialize voices when they become available
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = initializeVoices;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 's':
                        e.preventDefault();
                        saveData();
                        showNotification('Progress saved!');
                        break;
                    case 'Enter':
                        if (currentStep === 1) {
                            e.preventDefault();
                            generateScript();
                        }
                        break;
                }
            }
            
            if (e.key === 'Escape' && isPlaying) {
                stopPreview();
            }
        });

        // Auto-save functionality
        setInterval(() => {
            if (videoData.prompt || videoData.script || videoData.scenes.length > 0) {
                saveData();
            }
        }, 30000); // Auto-save every 30 seconds

        // Error handling for API failures
        window.addEventListener('unhandledrejection', function(event) {
            console.error('Unhandled promise rejection:', event.reason);
            showNotification('An error occurred. Please try again.', 'error');
        });

        // Performance optimization
        function optimizeCanvas() {
            const canvas = document.getElementById('exportCanvas');
            const ctx = canvas.getContext('2d');
            
            // Enable hardware acceleration if available
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        }

        // Initialize performance optimizations
        document.addEventListener('DOMContentLoaded', optimizeCanvas);
    </script>
</body>
</html>
